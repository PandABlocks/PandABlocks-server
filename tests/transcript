# Simple server test script.  Consists of commands to send and the expected
# response, the test_exchange script validates this.

# First check for out of order return
< *ECHO One response?
< *ECHO Second?
> OK =One response
> OK =Second

# Start with the identification exchange
# < *IDN?
# > OK =PandA
#
# < *IDN?
# > OK =PandA

# Simple echo command
< *ECHO this is an echo?
> OK =this is an echo

< *ECHO?
> ERR Character ' ' expected

# The simplest meta-data inquiry.
# Note that the order of the returned values depends on both the internal
# hashtable implementation and the ordering in the config file.
< *BLOCKS?
> !TTLIN 6
> !OUTENC 4
> !PCAP 1
> !PCOMP 4
> !TTLOUT 10
> !ADC 8
> !DIV 4
> !INENC 4
> !SLOW 1
> !PGEN 2
> !LVDSIN 2
> !POSITIONS 1
> !POSENC 4
> !SEQ 4
> !PULSE 4
> !SRGATE 4
> !LUT 8
> !LVDSOUT 2
> !COUNTER 8
> !ADDER 1
> !CLOCKS 1
> !BITS 1
> !QDEC 4
> .

# Now we can read and write some I/O fields
< TTLOUT1.VAL=TTLIN3.VAL
> OK

< TTLOUT1.VAL?
> OK =TTLIN3.VAL

< TTLOUT0.VAL=TTLIN0.VAL
< TTLOUT1.VAL=TTLIN1.VAL
< TTLOUT2.VAL=TTLIN2.VAL
< TTLOUT3.VAL=TTLIN3.VAL
< TTLOUT4.VAL=TTLIN4.VAL
< TTLOUT5.VAL=TTLIN5.VAL
< TTLOUT6.VAL=TTLIN0.VAL
< TTLOUT7.VAL=TTLIN1.VAL
< TTLOUT8.VAL=TTLIN2.VAL
< TTLOUT9.VAL=TTLIN3.VAL
< TTLOUT10.VAL=TTLIN3.VAL
> ERR Invalid block number
> OK
> OK
> OK
> OK
> OK
> ERR Label not found
> OK
> OK
> OK
> OK

< TTLOUT0.VAL?
< TTLOUT1.VAL?
< TTLOUT2.VAL?
< TTLOUT3.VAL?
< TTLOUT4.VAL?
< TTLOUT5.VAL?
< TTLOUT7.VAL?
< TTLOUT8.VAL?
< TTLOUT9.VAL?
> ERR Invalid block number
> OK =TTLIN1.VAL
> OK =TTLIN2.VAL
> OK =TTLIN3.VAL
> OK =TTLIN4.VAL
> OK =TTLIN5.VAL
> OK =TTLIN1.VAL
> OK =TTLIN2.VAL
> OK =TTLIN3.VAL

# Now a few top level error responses
< x
> ERR Unknown command

< *IDN?x
> ERR Unexpected text after command

< *x?
> ERR Unknown command

< *x=
> ERR Unknown command

< TTLIN.*=
> ERR Field not writeable


# Testing the parsing of entity names.  As these are quite complex there are a
# lot of error possibilities to work through.

< ?
> ERR No name found

< xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx?
> ERR Name too long

< x?
> ERR No such block

< TTLIN?
> ERR Missing field name

< TTLIN23?
> ERR Invalid block number

< TTLIN2?
> ERR Missing field name

< TTLIN2.x?
> ERR No such field

< TTLIN.VAL?
> ERR Missing block number

< TTLIN.VAL.?
> ERR Missing block number

< TTLIN1.VAL.?
> ERR No name found

< *IDN<
< 123
<
> ERR Not a table

< TTLIN2.VAL<
< 123
<
> ERR Field is not a table

< TTLIN.*?
> !VAL 1 bit_out
> !TERM 0 param enum
> .

< TTLIN2.VAL=x
> ERR Field not writeable

< TTLIN2.VAL=0
> ERR Field not writeable

< TTLIN2.TERM=High-Z
> OK

< TTLIN2.TERM?
> OK =High-Z

< TTLIN2.TERM.LABELS?
> !High-Z
> !50-Ohm
> .

< TTLIN2.TERM=50-Ohm
> OK

< TTLIN2.TERM.RAW?
< TTLIN2.TERM?
> ERR No such attribute
> OK =50-Ohm

< TTLIN2.TERM=blah
> ERR Label not found

< INENC3.BITS=33
> OK

< INENC3.BITS?
> OK =33

< INENC3.BITS=64
> ERR Number out of range

# Writing a value

< INENC1.SETP=23
> OK

# Unimplemented functionality

< PCOMP2.TABLE<
< 1 2 3 4 5 6 7 8
< 9
<
> OK

< PCOMP2.TABLE.LENGTH?
> OK =9

< PCOMP2.TABLE<B
< 1234567=
< ABCd
<
> OK

< PCOMP2.TABLE.LENGTH?
> OK =2

< PCOMP2.TABLE<<
< 1 2 3 4 5 6 7 8
< 9
<
> OK

< PCOMP2.TABLE.LENGTH?
> OK =11

< SEQ2.TABLE<
< 1 2 3 4 5 6 7 8
< 9
<
> OK

< SEQ2.TABLE<B
< 1234567
<
> ERR Invalid data length

< SEQ2.TABLE<B
< 123456789AB=
<
> OK

< SEQ2.TABLE<<
< 1 2 3 4 5 6 7 8
< 9
<
> OK

< SEQ2.TABLE?
> !3891817943
> !16055470
> !1
> !2
> !3
> !4
> !5
> !6
> !7
> !8
> !9
> .


< TTLIN.VAL.*?
> !CAPTURE_WORD
> !OFFSET
> !INFO
> .

< DIV.DIVISOR.*?
> !MAX
> !INFO
> .

< DIV1.DIVISOR.MAX?
> OK =4294967295

< INENC1.BITS.MAX?
> OK =63

< TTLIN2.TERM.ENUMS?
> ERR No such attribute

< TTLIN2.TERM.ENUMS=x
> ERR No such attribute


# There's a surprising delay on the block operations.  Try doing them all in one
# go instead.
< PCOMP2.TABLE<
< 1 2 3 4 5 6 7 8
< 9
<
< PCOMP2.TABLE<B
< 123456789AB=
<
< PCOMP2.TABLE<<
< 1 2 3 4 5 6 7 8
< 9
<
> OK
> OK
> OK

# Testing position fields
< QDEC.SETP.*?
> !UNITS
> !RAW
> !OFFSET
> !SCALE
> !INFO
> .


< PCOMP1.START.SCALE=0.1
> OK

< PCOMP1.START.OFFSET=100.3
> OK

< PCOMP1.START=123.45
> OK

< PCOMP1.START?
> OK =123.5

< PCOMP1.START.RAW?
> OK =232

< PCOMP1.START.SCALE?
> OK =0.1

< PCOMP1.START.OFFSET?
> OK =100.3

< PCOMP1.START.UNITS=mm
> OK

< PCOMP1.START.UNITS?
> OK =mm

< *ENUMS.PCOMP1.START.UNITS?
> !min
> !s
> !ms
> !us
> .

# Check change detection on offset and scale change
< *CHANGES.CONFIG=
> OK

< *CHANGES.CONFIG?
> .

< PCOMP1.START?
> OK =123.5

< PCOMP1.START.OFFSET?
< PCOMP1.START.SCALE?
> OK =100.3
> OK =0.1

< PCOMP1.START.OFFSET=0
< *CHANGES.CONFIG?
> OK
> !PCOMP1.START=23.2
> .

< PCOMP1.START.SCALE=1
< *CHANGES.CONFIG?
> OK
> !PCOMP1.START=232
> .


# LUT
< LUT.*?
> !FUNC 0 param lut
> !INPB 2 param bit_mux
> !INPC 3 param bit_mux
> !INPA 1 param bit_mux
> !VAL 6 bit_out
> !INPD 4 param bit_mux
> !INPE 5 param bit_mux
> .

< LUT1.INPC.INFO?
> OK =param bit_mux

< LUT.FUNC.*?
> !INFO
> !RAW
> .

< LUT1.FUNC=0x123
> OK

< LUT1.FUNC?
> OK =0x123

< LUT1.FUNC.RAW?
> OK =291

< LUT1.FUNC=A&B|C=>D^E
> OK

< LUT1.FUNC=A&F
> ERR Invalid token

< LUT1.FUNC?
> OK =A&B|C=>D^E

# Description fields
< *DESC.TTLIN?
> OK =TTL input

< *DESC.TTLIN.TERM?
> OK =Select TTL input termination

< *DESC.TTLIN.TERM.LABELS?
> OK =List of possible enumeration values

# Capture and capture index
< *CAPTURE=
> OK

< *CAPTURE?
> .

< TTLIN1.VAL.CAPTURE?
< TTLIN1.VAL.CAPTURE_WORD?
> ERR No such attribute
> OK =PCAP.BITA

< PCAP.BITA.CAPTURE?
> OK =No

< *ENUMS.PCAP.BITA.CAPTURE?
> !No
> !Capture
> .

< PCAP.BITA.CAPTURE=1
< PCAP.BITA.CAPTURE=Capture
> ERR Not a valid capture option
> OK

< *CAPTURE?
> !PCAP.BITA Capture
> .

< INENC2.POSN.CAPTURE=Triggered
> OK

< *CAPTURE?
> !INENC2.POSN Triggered
> !PCAP.BITA Capture
> .

# Change reporting
< *CHANGES.CONFIG=
> OK

< *CHANGES.CONFIG?
> .

< *CHANGES.ATTR=
> OK

< *CHANGES.ATTR?
> .

< INENC2.POSN.CAPTURE=Triggered
> OK

< *CHANGES.ATTR?
> !INENC2.POSN.CAPTURE=Triggered
> .

# Pulse time
< PULSE1.DELAY.UNITS=s
> OK

< PULSE1.DELAY=10
> OK

< PULSE1.DELAY.UNITS=ms
< PULSE1.DELAY?
< PULSE1.DELAY.UNITS=s
> OK
> OK =10000
> OK

< PULSE1.DELAY?
> OK =10

< PULSE1.DELAY=2251799
> OK

< PULSE1.DELAY?
> OK =2251799

< PULSE1.DELAY=2251800
> ERR Time setting out of range

< PULSE1.DELAY=1e99
> ERR Time setting out of range

< PULSE1.DELAY.RAW=3
> ERR Value too small

< PULSE1.DELAY=2e-8
> ERR Value too small

# Table support
< SEQ.TABLE.*?
> !MAX_LENGTH
> !B
> !LENGTH
> !FIELDS
> !INFO
> .

< SEQ1.TABLE.FIELDS?
> !31:0    NREPEATS
> !35:32   INPUT_MASK
> !39:36   TRIGGER_MASK
> !45:40   OUT_PH_A
> !51:46   OUT_PH_B
> !95:64   TIME_PH_A
> !127:96  TIME_PH_B
> .

< SEQ1.TABLE.MAX_LENGTH?
> OK =512

< SEQ1.TABLE<
<
> OK

< SEQ1.TABLE.LENGTH?
> OK =0

< SEQ1.TABLE<
< 1 2 3 4
<
> OK

< SEQ1.TABLE.LENGTH?
> OK =4

< SEQ1.TABLE.B?
> !AQAAAAIAAAADAAAABAAAAA==
> .

# Somewhat more challenging test taken from wikipedia.
< SEQ1.TABLE<B
< TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlz
< IHNpbmd1bGFyIHBhc3Npb24gZnJvbQo=
<
> OK

< SEQ1.TABLE.LENGTH?
> OK =20

< SEQ1.TABLE.B?
> !TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1
> !dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbQo=
> .

# Test some malformed table writes

# First, writes are taken until blank line, even if malformed
< X<blalba
< dfdex
< xxx
<
> ERR Unexpected character after input

# Next check that a broken write does nothing
< SEQ1.TABLE<
< 1234
< 999
< broken
<
< SEQ1.TABLE.LENGTH?
> ERR Number missing
> OK =20

# Now check some malformed base 64 writes
< SEQ1.TABLE<B
< abcdefgh
<
> ERR Invalid data length

< SEQ1.TABLE<B
< abcd*xyz
<
> ERR Malformed base64 string


# Check for change readbacks

< BITS.A_SET=0
< BITS.A?
< BITS.A_SET=1
< BITS.A?
> OK
> OK =0
> OK
> OK =1

# Turn the clocks off!
< CLOCKS.A_PERIOD=0
< CLOCKS.B_PERIOD=0
< CLOCKS.C_PERIOD=0
< CLOCKS.D_PERIOD=0
> OK
> OK
> OK
> OK

# Check that *CHANGES.BITS= actually works
< BITS.A_SET=0
< BITS.A_SET=1
< *CHANGES.BITS=
< *CHANGES.BITS?
> OK
> OK
> OK
> .

# Ok, this is what we expect
< BITS.A?
< BITS.A_SET=0
< BITS.A?
< BITS.A_SET=1
< BITS.A?
> OK =1
> OK
> OK =0
> OK
> OK =1

< BITS.A_SET=0
< *CHANGES.BITS?
< *CHANGES.BITS?
> OK
> !BITS.A=0
> .
> .

# Add some position capture tests
< PCAP.*?
> !FRAME_LENGTH 7 ext_out
> !CAPTURE_OFFSET 8 ext_out offset
> !ACTIVE 5 bit_out
> !BITA 10 ext_out bits
> !BITD 13 ext_out bits
> !BITC 12 ext_out bits
> !BITB 11 ext_out bits
> !ENABLE 0 param bit_mux
> !MISSED_CAPTURES 3 read uint
> !CAPTURE 2 param bit_mux
> !CAPTURE_TS 6 ext_out timestamp
> !ERR_STATUS 4 read uint
> !INJECT 14 write uint
> !FRAME 1 param bit_mux
> !ADC_COUNT 9 ext_out adc_count
> .

# Encoder enums
< *ENUMS.INENC.POSN.CAPTURE?
> !No
> !Triggered
> !Difference
> !Average
> !Extended
> .

< INENC1.POSN.CAPTURE=No
< INENC1.POSN.CAPTURE?
< INENC1.POSN.CAPTURE=Triggered
< INENC1.POSN.CAPTURE?
< INENC1.POSN.CAPTURE=Difference
< INENC1.POSN.CAPTURE?
< INENC1.POSN.CAPTURE=Extended
< INENC1.POSN.CAPTURE?
> OK
> OK =No
> OK
> OK =Triggered
> OK
> OK =Difference
> OK
> OK =Extended

< *ENUMS.PCAP.CAPTURE_TS.CAPTURE?
< PCAP.CAPTURE_TS?
> !No
> !Trigger
> !Frame
> .
> ERR Field not readable

# At the moment the capture state for this field is stuck at No
< PCAP.CAPTURE_TS.CAPTURE=Frame
< PCAP.CAPTURE_TS.CAPTURE?
> OK
> OK =Frame
