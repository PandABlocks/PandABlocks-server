# Generates definitions of named registers from *REG entry in config file.

from __future__ import print_function

import sys

from parse_indent import parse_register_file
blocks, constants = parse_register_file(sys.argv[1])

base, fields = blocks['*REG']


# For each field process the field definition: it is a register base optionally
# followed by a range.
def fixup_fields(name, value):
    values = value.split()
    optional = values[0] == 'opt'
    if optional:
        values = values[1:]
    start = int(values[0])
    if values[1:]:
        middle, end = values[1:]
        assert middle == '..', 'Malformed range'
        count = int(end) - start + 1
    else:
        count = 1
    return name, start, count, optional

fields = [fixup_fields(name, value) for name, value in fields]


print('''\
/* Definitions of register names from *REG fields of the register configuration
 * file.  This file is re-read and confirmed equal on startup.
 *
 * This file is automatically generated from server/named_registers.py and
 * config_d/registers.
 *
 * DO NOT EDIT THIS FILE, edit the sources instead! */
''')

# First generate the #define statements
print('#define REG_BLOCK_BASE %s' % base)
print()
for name, value, _, _ in fields:
    print('#define %s %s' % (name, value))

# Now generate offset name table used for checking.
print('''
static struct named_register named_registers[] = {''')
for name, _, count, opt in fields:
    print('    [%s] = { "%s", %d, false, %d },' % (name, name, count, opt))
print('};')

# Generate table of constants read from config file
print('''
static struct named_constant named_constants[] = {''')
for name, value in constants.items():
    # A little backwards compatibility hack: if the value of a constant is zero
    # it is allowed to be missing from the register file
    value = int(value)
    default = 'true' if value == 0 else 'false'
    print('    { "%s", %u, %s },' % (name, int(value), default))
print('};')
