#!/usr/bin/env python2

# Simple template for a support server.

import argparse
import os
import sys
import imp
import socket
import traceback


parser = argparse.ArgumentParser(description = 'PandA Extension Server')
parser.add_argument(
    '-d', '--daemon', action = 'store_true', help = 'Run as daemon process')
parser.add_argument(
    '-v', '--verbose', action = 'store_true', help = 'Log register access')
parser.add_argument(
    '-p', '--port', default = 9999, type = int, help = 'Specify socket port')
parser.add_argument(
    'extensions', help = 'Extension directory')
args = parser.parse_args()


# Initialise the extensions module from the path given to us.  We load this
# directory as a package.
imp.load_module(
    'extensions', None, args.extensions, ('', '', imp.PKG_DIRECTORY))


# Imports the named module from the extensions directory.  We use __import__
# rather than importlib simply to keep Python 2.6 compatibility for now.
def import_extension_module(name):
    extensions = __import__('extensions', None, None, [name])
    return getattr(extensions, name)


class Extensions:
    def __init__(self):
        self.id_table = {}
        self.next_id = 0

    # Adds an entity to the id table and returns the associated id.
    def add_entity(self, entity):
        id = self.next_id
        self.next_id += 1
        self.id_table[id] = entity
        return id

    def parse(self, line):
        try:
            # Initial parsing of line before handing over to module.  The syntax
            # is
            #       ("R"|"W") module-name [ " " parse-args ]
            #
            # The fiddly bit is splitting module-nane and the args
            rw = line[0]
            try:
                module_name, parse_args = line[1:].split(' ', 1)
            except ValueError:
                module_name, parse_args = line[1:], ''

            module = import_extension_module(module_name)
            parse = module.parse(rw, parse_args)

            assert rw in 'RW', 'Invalid R/W field in parse'
            if rw == 'R':
                assert hasattr(parse, 'read'), 'Read method not supported'
            elif rw == 'W':
                assert hasattr(parse, 'write'), 'Write method not supported'

            return (False, self.add_entity(parse))
        except Exception as e:
            if args.verbose:
                print >>sys.stderr, 'Caught exception during parse', e
                traceback.print_exc()

            # Convert parse exception into an error message.  It can happen that
            # the error message is empty, eg an unqualified assert fail, so
            # let's return something less obscure.
            e = str(e)
            if not e:
                e = 'Unknown error'
            return (True, e)

    def write(self, line):
        id, number, value = map(int, line.split(' ', 2))
        self.id_table[id].write(number, value)

    def read(self, line):
        id, number = map(int, line.split(' ', 1))
        return self.id_table[id].read(number)


def run_extensions_server(sock, verbose):
    sock_file = sock.makefile()
    extensions = Extensions()
    while True:
        line = sock_file.readline()[:-1]    # Prune trailing \n
        if not line:
            break

        try:
            if args.verbose:
                print >>sys.stderr, 'Read:', repr(line)
            cmd, line = line[0], line[1:]
            if cmd == 'P':
                error, response = extensions.parse(line)
                if error:
                    # Truncate error response to avoid overrun errors
                    sock_file.write('E%s\n' % response[:250])
                else:
                    sock_file.write('P%u\n' % response)
                sock_file.flush()
            elif cmd == 'W':
                extensions.write(line)
            elif cmd == 'R':
                value = extensions.read(line)
                sock_file.write('R%u\n' % value)
                sock_file.flush()
            else:
                assert False, 'Invalid command character \'%c\'' % cmd
        except Exception as e:
            print >>sys.stderr, 'Unexpected exception', e
            traceback.print_exc()


# We daemonise the server by double forking, but we leave the controlling
# terminal and other file connections alone.
def daemonise():
    if os.fork():
        # Exit first parent
        sys.exit(0)
    # Do second fork to avoid generating zombies
    if os.fork():
        sys.exit(0)


server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
server_sock.bind(('localhost', args.port))
server_sock.listen(0)

print >>sys.stderr, 'Extension server ready'
# Need to daemonise after the listening port is ready but before calling accept.
# This ensures that when our caller gets control the connection will succeed.
if args.daemon:
    daemonise()

(conn, addr) = server_sock.accept()
server_sock.close()

conn.setsockopt(socket.SOL_TCP, socket.TCP_NODELAY, 1)
try:
    run_extensions_server(conn, args.verbose)
except KeyboardInterrupt:
    pass
print >>sys.stderr, 'Extension server closed'
